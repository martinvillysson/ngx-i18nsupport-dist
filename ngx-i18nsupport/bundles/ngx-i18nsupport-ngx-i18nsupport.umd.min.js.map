{"version":3,"sources":["../../../projects/xliffmerge/src/lib/xliffmerge.module.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/xliffmerge/src/common/util.ts","../../../projects/xliffmerge/src/common/command-output.ts","../../../projects/xliffmerge/src/common/writer-to-string.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-error.ts","../../../projects/xliffmerge/src/common/file-util.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extraction-pattern.ts","../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extractor.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge-parameters.ts","../../../projects/xliffmerge/src/xliffmerge/version.ts","../../../projects/xliffmerge/src/xliffmerge/xml-reader.ts","../../../projects/xliffmerge/src/xliffmerge/translation-messages-file-reader.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-service.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-result.ts","../../../projects/xliffmerge/src/autotranslate/auto-translate-summary-report.ts","../../../projects/xliffmerge/src/autotranslate/xliff-merge-auto-translate-service.ts","../../../projects/xliffmerge/src/xliffmerge/xliff-merge.ts"],"names":["XliffmergeModule","imports","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","isNullOrUndefined","isArray","LogLevel","WriterToString","_this","_super","resultString","_write","chunk","encoding","callback","chunkString","Buffer","toString","alloc","writtenData","Writable","CommandOutput","stdout","_quiet","_verbose","outputStream","process","setVerbose","setQuiet","verbose","quiet","msg","params","_i","log","ERROR","warn","WARN","info","INFO","debug","DEBUG","level","isOutputEnabled","coloredMessage","chalk","red","magenta","gray","outMsg","format","apply","write","quietEnabled","verboseEnabled","XliffMergeError","Error","FileUtil","exists","filename","fs.existsSync","read","fs.readFileSync","replaceContent","newContent","fs.writeFileSync","copy","srcFile","destFile","buff","fdr","fs.openSync","fdw","bytesRead","pos","fs.readSync","fs.writeSync","fs.closeSync","deleteFolderRecursive","path","fs.readdirSync","forEach","file","curPath","fs.lstatSync","isDirectory","fs.unlinkSync","fs.rmdirSync","deleteFolderContentRecursive","deleteFile","NgxTranslateExtractionPattern","extractionPatternString","parts","split","_matchExplicitId","_descriptionPatterns","part","errorString","checkValidDescriptionPattern","isExplicitIdMatched","id","isDescriptionMatched","description","indexOf","descriptionPattern","test","NgxTranslateExtractor","messagesFile","extractionPattern","checkPattern","message","extract","outputFile","extractTo","translations","toNgxTranslations","keys","JSON","stringify","result","forEachTransUnit","tu","ngxId","ngxTranslateIdFromTU","messagetext","targetContentNormalized","asDisplayString","NORMALIZATION_FORMAT_NGXTRANSLATE","isExplicitlySetId","meaning","msgList","translationObject","putInTranslationObject","firstPartOfId","restOfId","indexOfDot","substring","object","DefaultExtractionPattern","PROFILE_CANDIDATES","XliffMergeParameters","errorsFound","warningsFound","createFromOptions","options","profileContent","parameters","configure","readProfileCandidate","profilePath","content","err","parsedContent","parse","xliffmergeOptions","readProfile","validProfile","initializeFromConfig","languages","_languages","_defaultLanguage","checkParameters","PROFILE_CANDIDATES_1","PROFILE_CANDIDATES_1_1","configfilename","profile","usedProfilePath","srcDir","adjustPathToProfilePath","genDir","apikeyfile","pathToAdjust","isAbsolute","join","dirname","replace","allowIdChange","_allowIdChange","defaultLanguage","_srcDir","angularCompilerOptions","_genDir","i18nBaseFile","_i18nBaseFile","i18nFile","_i18nFile","i18nFormat","_i18nFormat","_encoding","removeUnusedIds","_removeUnusedIds","supportNgxTranslate","_supportNgxTranslate","ngxTranslateExtractionPattern","_ngxTranslateExtractionPattern","useSourceAsTarget","_useSourceAsTarget","targetPraefix","_targetPraefix","targetSuffix","_targetSuffix","autotranslate","_autotranslate","beautifyOutput","_beautifyOutput","preserveOrder","_preserveOrder","apikey","_apikey","_apikeyfile","stats","checkLanguageSyntax","lang","fs.statSync","fs.accessSync","fs.constants","R_OK","autotranslatedLanguages","checkResult","showAllParameters","commandOutput","_b","_c","language","generatedI18nFile","suffixForGeneratedI18nFile","generatedNgxTranslateFile","autotranslateLanguage","slice","apikeyPath","env","API_KEY_FILE","pkg","require","path.resolve","__dirname","VERSION","version","XmlReader","readXmlFileContent","DEFAULT_ENCODING","foundEncoding","encodingFromXml","xmlString","index","endIndex","TranslationMessagesFileReader","fromFile","optionalMasterFilePath","xmlContent","optionalMaster","masterFileContent","TranslationMessagesFileFactory","fromFileContent","fromUnknownFormatFile","fromUnknownFormatFileContent","masterXmlContent","save","editedContent","AutoTranslateService","apiKey","_request","request","_apiKey","_rootUrl","stripRegioncode","langLower","toLowerCase","c","charAt","setApiKey","translateMultipleStrings","messages","from","to","of","throwError","allRequests","splitMessagesToGoogleLimit","map","partialMessages","limitedTranslateMultipleStrings","forkJoin","pipe","allTranslations","all","currentPackage","packageSize","realUrl","url","body","q","target","source","json","post","data","code","translation","translatedText","uri","_call","assign","method","Observable","observer","response","complete","AutoTranslateResult","_success","_details","success","AutoTranslateSummaryReport","_from","_to","_total","_ignored","_failed","setError","total","_error","setIgnored","ignored","addSingleResult","merge","anotherSummary","failed","XliffMergeAutoTranslateService","autoTranslateService","autoTranslate","languageSpecificMessagesFile","doAutoTranslateNonICUMessages","doAutoTranslateICUMessages","summaries","summary","allUntranslatedTUs","allUntranslated","targetState","STATE_NEW","allTranslatable","filter","sourceContentNormalized","getICUMessage","allMessages","encodedTranslation","entityDecoderLib.decode","translationText","autoTranslateNonICUUnit","catchError","failSummary","doAutoTranslateICUMessage","categories","getCategories","find","category","getMessageNormalized","icuTranslation","getCategory","autoTranslateICUUnit","translatedMessage","autoTranslateUnit","translate","translateICUMessage","errors","validate","warnings","validateWarnings","XliffMerge","main","argv","parseArgs","run","exit","arg","console","showUsage","instance","callbackFunction","errorFunction","runAsync","subscribe","retcode","_d","_e","_f","readMaster","executionForAllLanguages","processLanguage","retcodes","totalRetcode","master","warning","count","numberOfTransUnits","missingIdCount","numberOfTransUnitsWithMissingId","sourceLang","sourceLanguage","setSourceLanguage","currentFilename","filenameString","languageXliffFile","mergeMasterTo","createUntranslatedXliff","translationFormat","languageXliffFilePath","isDefaultLang","setNewTransUnitTargetPraefix","setNewTransUnitTargetSuffix","createTranslationFileForLang","FORMAT_XMB","FORMAT_XTB","newCount","correctSourceContentCount","correctSourceRefCount","correctDescriptionOrMeaningCount","idChangedCount","lastProcessedUnit","masterTransUnit","transUnit","transUnitWithId","supportsSetSourceContent","areSourcesNearlyEqual","setSourceContent","sourceContent","setTargetState","STATE_FINAL","STATE_TRANSLATED","supportsSetSourceReferences","areSourceReferencesEqual","sourceReferences","setSourceReferences","supportsSetDescriptionAndMeaning","changed","setDescription","setMeaning","newUnit","processChangedIdUnit","importNewTransUnit","undefined","removeCount","removeTransUnitWithId","changedTransUnit","languageTransUnit","mergedTransUnit","translatedContent","targetContent","tu1","tu2","tu1Normalized","tu2Normalized","isICUMessage","asNativeString","trim","containsICUMessageRef","NORMALIZATION_FORMAT_DEFAULT","ref1","ref2","set1","Set","ref","add","sourcefile","linenumber","set2","size","match","has","autotranslateEnabled"],"mappings":"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","sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n// not used, only there to make ng-packagr happy\r\n@NgModule({\r\n    imports: [\r\n    ],\r\n    declarations: [],\r\n    exports: []\r\n})\r\nexport class XliffmergeModule { }\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\r\n * Collection of utility functions that are deprecated in nodes util.\r\n */\r\n\r\n/**\r\n * Replaces node isNullOrUndefined.\r\n */\r\nexport function isNullOrUndefined(value: any) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n/**\r\n * Replaces node isString.\r\n */\r\nexport function isString(value: any) {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Replaces node isBoolean.\r\n */\r\nexport function isBoolean(value: any) {\r\n    return typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Replaces node isNumber.\r\n */\r\nexport function isNumber(value: any) {\r\n    return typeof value === 'number';\r\n}\r\n\r\n/**\r\n * Replaces node isArray.\r\n */\r\nexport function isArray(value: any) {\r\n    return Array.isArray(value);\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Very simple class to control the output of a command.\r\n * Output can be errors, warnings, infos and debug-Outputs.\r\n * The output can be controlled via 2 flags, quiet and verbose.\r\n * If quit is enabled only error messages are shown.\r\n * If verbose is enabled, everything is shown.\r\n * If both are not enabled (the default) errors, warnings and infos are shown.\r\n * If not are enabled (strange), we assumed the default.\r\n */\r\n\r\nimport chalk from 'chalk';\r\nimport WritableStream = NodeJS.WritableStream;\r\nimport {format} from 'util';\r\n\r\nenum LogLevel {\r\n    'ERROR',\r\n    'WARN',\r\n    'INFO',\r\n    'DEBUG'\r\n}\r\n\r\nexport class CommandOutput {\r\n\r\n    /**\r\n     * verbose enables output of everything.\r\n     */\r\n    public _verbose: boolean;\r\n\r\n    /**\r\n     * quiet disables output of everything but errors.\r\n     */\r\n    public _quiet: boolean;\r\n\r\n    private outputStream: WritableStream;\r\n\r\n    constructor(stdout?: WritableStream) {\r\n        this._quiet = false;\r\n        this._verbose = false;\r\n        if (stdout) {\r\n            this.outputStream = stdout;\r\n        } else {\r\n            this.outputStream = process.stdout;\r\n        }\r\n    }\r\n\r\n    public setVerbose() {\r\n        this._verbose = true;\r\n    }\r\n\r\n    public setQuiet() {\r\n        this._quiet = true;\r\n    }\r\n\r\n    /**\r\n     * Test, wether verbose is enabled.\r\n     * @return wether verbose is enabled.\r\n     */\r\n    public verbose(): boolean {\r\n        return this._verbose;\r\n    }\r\n\r\n    /**\r\n     * Test, wether quiet is enabled.\r\n     * @return wether quiet is enabled.\r\n     */\r\n    public quiet(): boolean {\r\n        return this._quiet;\r\n    }\r\n\r\n    public error(msg, ...params: any[]) {\r\n        this.log(LogLevel.ERROR, msg, params);\r\n    }\r\n\r\n    public warn(msg, ...params: any[]) {\r\n        this.log(LogLevel.WARN, msg, params);\r\n    }\r\n\r\n    public info(msg, ...params: any[]) {\r\n        this.log(LogLevel.INFO, msg, params);\r\n    }\r\n\r\n    public debug(msg, ...params: any[]) {\r\n        this.log(LogLevel.DEBUG, msg, params);\r\n    }\r\n\r\n    private log(level: LogLevel, msg, params: any[]) {\r\n        if (!this.isOutputEnabled(level)) {\r\n            return;\r\n        }\r\n        let coloredMessage;\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                coloredMessage = chalk.red('ERROR: ' + msg);\r\n                break;\r\n            case LogLevel.WARN:\r\n                coloredMessage = chalk.magenta('WARNING: ' + msg);\r\n                break;\r\n            default:\r\n                coloredMessage = chalk.gray('* ' + msg);\r\n                break;\r\n        }\r\n        const outMsg = format(coloredMessage, ...params);\r\n        this.outputStream.write(outMsg + '\\n');\r\n    }\r\n\r\n    private isOutputEnabled(level: LogLevel): boolean {\r\n        let quietEnabled, verboseEnabled: boolean;\r\n        if (this._quiet && this._verbose) {\r\n            quietEnabled = false;\r\n            verboseEnabled = false;\r\n        } else {\r\n            quietEnabled = this._quiet;\r\n            verboseEnabled = this._verbose;\r\n        }\r\n        switch (level) {\r\n            case LogLevel.ERROR:\r\n                return true;    // always output errors\r\n            case LogLevel.WARN:\r\n                return (!quietEnabled);\r\n            case LogLevel.INFO:\r\n                return (verboseEnabled && !quietEnabled);\r\n            case LogLevel.DEBUG:\r\n                return verboseEnabled;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n}\r\n","import {Writable} from 'stream';\r\nimport {isString} from './util';\r\n/**\r\n * Created by martin on 20.02.2017.\r\n * A helper class for testing.\r\n * Can be used as a WritableStream and writes everything (synchronously) into a string,\r\n * that can easily be read by the tests.\r\n */\r\n\r\nexport class WriterToString extends Writable {\r\n\r\n    private resultString: string;\r\n\r\n    constructor() {\r\n        super();\r\n        this.resultString = '';\r\n    }\r\n\r\n    public _write(chunk: any, encoding: string, callback: Function): void {\r\n        let chunkString;\r\n        if (isString(chunk)) {\r\n            chunkString = chunk;\r\n        } else if (chunk instanceof Buffer) {\r\n            chunkString = chunk.toString();\r\n        } else {\r\n            chunkString = Buffer.alloc(chunk).toString(encoding);\r\n        }\r\n        this.resultString = this.resultString + chunkString;\r\n        callback();\r\n    }\r\n\r\n    /**\r\n     * Returns a string of everything, that was written to the stream so far.\r\n     * @return written data\r\n     */\r\n    public writtenData(): string {\r\n        return this.resultString;\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n */\r\n\r\nexport class XliffMergeError extends Error {\r\n\r\n    constructor(msg: string) {\r\n        super(msg);\r\n\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, XliffMergeError.prototype);\r\n    }\r\n}\r\n","import * as fs from 'fs';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * Some (a few) simple utils for file operations.\r\n * Just for convenience.\r\n */\r\n\r\nexport class FileUtil {\r\n\r\n    /**\r\n     * Check for existence.\r\n     * @param filename filename\r\n     * @return wether file exists\r\n     */\r\n    public static exists(filename: string) {\r\n        return fs.existsSync(filename);\r\n    }\r\n\r\n    /**\r\n     * Read a file.\r\n     * @param filename filename\r\n     * @param encoding encoding\r\n     * @return content of file\r\n     */\r\n    public static read(filename: string, encoding: string) {\r\n        return fs.readFileSync(filename, encoding);\r\n    }\r\n\r\n    /**\r\n     * Write a file with given content.\r\n     * @param filename filename\r\n     * @param newContent newContent\r\n     * @param encoding encoding\r\n     */\r\n    public static replaceContent(filename: string, newContent: string, encoding: string) {\r\n        fs.writeFileSync(filename, newContent, {encoding: encoding});\r\n    }\r\n\r\n    public static copy(srcFile: string, destFile: string) {\r\n        const BUF_LENGTH = 64 * 1024;\r\n        const buff = Buffer.alloc(BUF_LENGTH);\r\n        const fdr = fs.openSync(srcFile, 'r');\r\n        const fdw = fs.openSync(destFile, 'w');\r\n        let bytesRead = 1;\r\n        let pos = 0;\r\n        while (bytesRead > 0) {\r\n            bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);\r\n            fs.writeSync(fdw, buff, 0, bytesRead);\r\n            pos += bytesRead;\r\n        }\r\n        fs.closeSync(fdr);\r\n        fs.closeSync(fdw);\r\n    }\r\n\r\n    /**\r\n     * Delete the folder and all of its content (rm -rf).\r\n     * @param path path\r\n     */\r\n    public static deleteFolderRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path) ) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function(file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n            fs.rmdirSync(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete folders content recursively, but do not delete folder.\r\n     * Folder is left empty at the end.\r\n     * @param path path\r\n     */\r\n    public static deleteFolderContentRecursive(path: string) {\r\n        let files = [];\r\n        if (fs.existsSync(path) ) {\r\n            files = fs.readdirSync(path);\r\n            files.forEach(function(file) {\r\n                const curPath = path + '/' + file;\r\n                if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                    FileUtil.deleteFolderRecursive(curPath);\r\n                } else { // delete file\r\n                    fs.unlinkSync(curPath);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a file.\r\n     * @param path path\r\n     */\r\n    public static deleteFile(path: string) {\r\n        fs.unlinkSync(path);\r\n    }\r\n}\r\n","/**\r\n * Helper class to parse ngx translate extraction pattern\r\n * and to decide wether a given message matches the pattern.\r\n */\r\nexport class NgxTranslateExtractionPattern {\r\n\r\n    private _matchExplicitId: boolean;\r\n    private _descriptionPatterns: string[];\r\n\r\n    /**\r\n     * Construct the pattern from given description string\r\n     * @param extractionPatternString extractionPatternString\r\n     * @throws an error, if there is a syntax error\r\n     */\r\n    constructor(private extractionPatternString: string) {\r\n        const parts = extractionPatternString.split('|');\r\n        this._matchExplicitId = false;\r\n        this._descriptionPatterns = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            if (part === '@@') {\r\n                if (this._matchExplicitId) {\r\n                    throw new Error('extraction pattern must not contain @@ twice');\r\n                }\r\n                this._matchExplicitId = true;\r\n            } else {\r\n                const errorString = this.checkValidDescriptionPattern(part);\r\n                if (errorString) {\r\n                    throw new Error(errorString);\r\n                }\r\n                this._descriptionPatterns.push(part);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check, wether an explicitly set id matches the pattern.\r\n     * @param id id\r\n     * @return wether an explicitly set id matches the pattern.\r\n     */\r\n    public isExplicitIdMatched(id: string): boolean {\r\n        return id && this._matchExplicitId;\r\n    }\r\n\r\n    /**\r\n     * Check, wether a given description matches the pattern.\r\n     * @param description description\r\n     * @return wether a given description matches the pattern.\r\n     */\r\n    public isDescriptionMatched(description: string): boolean {\r\n        return this._descriptionPatterns.indexOf(description) >= 0;\r\n    }\r\n\r\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\r\n        if (!descriptionPattern) {\r\n            return 'empty value not allowed';\r\n        }\r\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\r\n            return null; // it is ok\r\n        } else {\r\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\r\n        }\r\n    }\r\n}\r\n","import {ITranslationMessagesFile, ITransUnit, NORMALIZATION_FORMAT_NGXTRANSLATE} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {NgxTranslateExtractionPattern} from './ngx-translate-extraction-pattern';\r\n/**\r\n * Created by roobm on 15.03.2017.\r\n * A tool for extracting messages in ngx-translate format.\r\n * Generates a json-file to be used with ngx-translate.\r\n */\r\n\r\n/**\r\n * The interface used for translations in ngx-translate.\r\n * A hash that contains either the translation or another hash.\r\n */\r\ninterface NgxTranslations {\r\n    [id: string]: NgxTranslations | string;\r\n}\r\n\r\n/**\r\n * internal,\r\n * a message with id (a dot-separated string).\r\n */\r\ninterface NgxMessage {\r\n    id: string; // dot separated name, e.g. \"myapp.service1.message1\"\r\n    message: string; // the message, placeholder are in {{n}} syntax, e.g. \"a test with value: {{0}}\r\n}\r\n\r\nexport class NgxTranslateExtractor {\r\n\r\n    public static DefaultExtractionPattern = '@@|ngx-translate';\r\n    private extractionPattern: NgxTranslateExtractionPattern;\r\n\r\n    /**\r\n     * Check, wether extractionPattern has valid syntax.\r\n     * @param extractionPatternString extractionPatternString\r\n     * @return null, if pattern is ok, string describing the error, if it is not ok.\r\n     */\r\n    public static checkPattern(extractionPatternString: string): string {\r\n        try {\r\n          if (new NgxTranslateExtractionPattern(extractionPatternString)) {\r\n              return null;\r\n          }\r\n        } catch (error) {\r\n            return error.message;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static extract(messagesFile: ITranslationMessagesFile, extractionPattern: string, outputFile: string) {\r\n        new NgxTranslateExtractor(messagesFile, extractionPattern).extractTo(outputFile);\r\n    }\r\n\r\n    constructor(private messagesFile: ITranslationMessagesFile, extractionPatternString: string) {\r\n        this.extractionPattern = new NgxTranslateExtractionPattern(extractionPatternString);\r\n    }\r\n\r\n    /**\r\n     * Extact messages and write them to a file.\r\n     * @param outputFile outputFile\r\n     */\r\n    public extractTo(outputFile: string) {\r\n        const translations: NgxTranslations = this.toNgxTranslations(this.extract());\r\n        if (translations && Object.keys(translations).length > 0) {\r\n            FileUtil.replaceContent(outputFile, JSON.stringify(translations, null, 4), 'UTF-8');\r\n        } else {\r\n            if (FileUtil.exists(outputFile)) {\r\n                FileUtil.deleteFile(outputFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Extract messages and convert them to ngx translations.\r\n     *  @return the translation objects.\r\n     */\r\n    private extract(): NgxMessage[] {\r\n        const result: NgxMessage[] = [];\r\n        this.messagesFile.forEachTransUnit((tu: ITransUnit) => {\r\n            const ngxId = this.ngxTranslateIdFromTU(tu);\r\n            if (ngxId) {\r\n                const messagetext = tu.targetContentNormalized().asDisplayString(NORMALIZATION_FORMAT_NGXTRANSLATE);\r\n                result.push({id: ngxId, message: messagetext});\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check, wether this tu should be extracted for ngx-translate usage, and return its id for ngx-translate.\r\n     * There are 2 possibilities:\r\n     * 1. description is set to \"ngx-translate\" and meaning contains the id.\r\n     * 2. id is explicitly set to a string.\r\n     * @param tu tu\r\n     * @return an ngx id or null, if this tu should not be extracted.\r\n     */\r\n    private ngxTranslateIdFromTU(tu: ITransUnit): string {\r\n        if (this.isExplicitlySetId(tu.id)) {\r\n            if (this.extractionPattern.isExplicitIdMatched(tu.id)) {\r\n                return tu.id;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        const description = tu.description();\r\n        if (description && this.extractionPattern.isDescriptionMatched(description)) {\r\n            return tu.meaning();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether ID was explicitly set (via i18n=\"@myid).\r\n     * Just heuristic, an ID is explicitly, if it does not look like a generated one.\r\n     * @param id id\r\n     * @return wether ID was explicitly set (via i18n=\"@myid).\r\n     */\r\n    private isExplicitlySetId(id: string): boolean {\r\n        if (isNullOrUndefined(id)) {\r\n            return false;\r\n        }\r\n        // generated IDs are either decimal or sha1 hex\r\n        const reForGeneratedId = /^[0-9a-f]{11,}$/;\r\n        return !reForGeneratedId.test(id);\r\n    }\r\n\r\n    /**\r\n     * Convert list of relevant TUs to ngx translations object.\r\n     * @param msgList msgList\r\n     */\r\n    private toNgxTranslations(msgList: NgxMessage[]): NgxTranslations {\r\n        const translationObject: NgxTranslations = {};\r\n        msgList.forEach((msg: NgxMessage) => {\r\n            this.putInTranslationObject(translationObject, msg);\r\n        });\r\n        return translationObject;\r\n    }\r\n\r\n    /**\r\n     * Put a new messages into the translation data object.\r\n     * If you add, e.g. \"{id: 'myapp.example', message: 'test'}\",\r\n     * the translation object will then contain an object myapp that has property example:\r\n     * {myapp: {\r\n     *   example: 'test'\r\n     *   }}\r\n     * @param translationObject translationObject\r\n     * @param msg msg\r\n     */\r\n    private putInTranslationObject(translationObject: NgxTranslations, msg: NgxMessage) {\r\n        let firstPartOfId: string;\r\n        let restOfId: string;\r\n        const indexOfDot = msg.id.indexOf('.');\r\n        if (indexOfDot === 0 || indexOfDot === (msg.id.length - 1)) {\r\n            throw new Error('bad nxg-translate id \"' + msg.id + '\"');\r\n        }\r\n        if (indexOfDot < 0) {\r\n            firstPartOfId = msg.id;\r\n            restOfId = '';\r\n        } else {\r\n            firstPartOfId = msg.id.substring(0, indexOfDot);\r\n            restOfId = msg.id.substring(indexOfDot + 1);\r\n        }\r\n        let object = translationObject[firstPartOfId];\r\n        if (isNullOrUndefined(object)) {\r\n            if (restOfId === '') {\r\n                translationObject[firstPartOfId] = msg.message;\r\n                return;\r\n            }\r\n            object = {};\r\n            translationObject[firstPartOfId] = object;\r\n        } else {\r\n            if (restOfId === '') {\r\n                throw new Error('duplicate id praefix \"' + msg.id + '\"');\r\n            }\r\n        }\r\n        this.putInTranslationObject(<NgxTranslations> object, {id: restOfId, message: msg.message});\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 17.02.2017.\r\n * Collection of all parameters used by the tool.\r\n * The parameters are read form the profile or defaults are used.\r\n */\r\n\r\nimport * as fs from 'fs';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {Stats} from 'fs';\r\nimport {CommandOutput} from '../common/command-output';\r\nimport {format} from 'util';\r\nimport {isArray, isNullOrUndefined} from '../common/util';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {dirname, isAbsolute, join, normalize} from 'path';\r\n\r\nconst PROFILE_CANDIDATES = ['package.json', '.angular-cli.json'];\r\n\r\nexport class XliffMergeParameters {\r\n\r\n    private usedProfilePath: string;\r\n    private _quiet: boolean;\r\n    private _verbose: boolean;\r\n    private _allowIdChange: boolean;\r\n    private _defaultLanguage: string;\r\n    private _srcDir: string;\r\n    private _i18nBaseFile: string;\r\n    private _i18nFile: string;\r\n    private _i18nFormat: string;\r\n    private _encoding: string;\r\n    private _genDir: string;\r\n    private _languages: string[];\r\n    private _removeUnusedIds: boolean;\r\n    private _supportNgxTranslate: boolean;\r\n    private _ngxTranslateExtractionPattern: string;\r\n    private _useSourceAsTarget: boolean;\r\n    private _targetPraefix: string;\r\n    private _targetSuffix: string;\r\n    private _beautifyOutput: boolean;\r\n    private _preserveOrder: boolean;\r\n    private _autotranslate: boolean|string[];\r\n    private _apikey: string;\r\n    private _apikeyfile: string;\r\n\r\n    public errorsFound: XliffMergeError[];\r\n    public warningsFound: string[];\r\n\r\n    /**\r\n     * Create Parameters.\r\n     * @param options command options\r\n     * @param profileContent given profile (if not, it is read from the profile path from options).\r\n     */\r\n    public static createFromOptions(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const parameters = new XliffMergeParameters();\r\n        parameters.configure(options, profileContent);\r\n        return parameters;\r\n    }\r\n\r\n    private constructor() {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n    }\r\n\r\n    /**\r\n     * Read potential profile.\r\n     * To be a candidate, file must exist and contain property \"xliffmergeOptions\".\r\n     * @param profilePath path of profile\r\n     * @return parsed content of file or null, if file does not exist or is not a profile candidate.\r\n     */\r\n    private static readProfileCandidate(profilePath: string): IConfigFile {\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'UTF-8');\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n        const parsedContent: IConfigFile = JSON.parse(content);\r\n        if (parsedContent && parsedContent.xliffmergeOptions) {\r\n            return parsedContent;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize me from the profile content.\r\n     * (public only for test usage).\r\n     * @param options options given at runtime via command line\r\n     * @param profileContent if null, read it from profile.\r\n     */\r\n    private configure(options: ProgramOptions, profileContent?: IConfigFile) {\r\n        this.errorsFound = [];\r\n        this.warningsFound = [];\r\n        if (!profileContent) {\r\n            profileContent = this.readProfile(options);\r\n        }\r\n        const validProfile: boolean = (!!profileContent);\r\n        if (options.quiet) {\r\n            this._quiet = options.quiet;\r\n        }\r\n        if (options.verbose) {\r\n            this._verbose = options.verbose;\r\n        }\r\n        if (validProfile) {\r\n            this.initializeFromConfig(profileContent);\r\n            // if languages are given as parameters, they ovveride everything said in profile\r\n            if (!!options.languages && options.languages.length > 0) {\r\n                this._languages = options.languages;\r\n                if (!this._defaultLanguage) {\r\n                    this._defaultLanguage = this._languages[0];\r\n                }\r\n            }\r\n            this.checkParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read profile.\r\n     * @param options program options\r\n     * @return the read profile (empty, if none, null if errors)\r\n     */\r\n    private readProfile(options: ProgramOptions): IConfigFile {\r\n        const profilePath: string = options.profilePath;\r\n        if (!profilePath) {\r\n            for (const configfilename of PROFILE_CANDIDATES) {\r\n                const profile = XliffMergeParameters.readProfileCandidate(configfilename);\r\n                if (profile) {\r\n                    this.usedProfilePath = configfilename;\r\n                    return profile;\r\n                }\r\n            }\r\n            return {};\r\n        }\r\n        let content: string;\r\n        try {\r\n            content = fs.readFileSync(profilePath, 'UTF-8');\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('could not read profile \"' + profilePath + '\"'));\r\n            return null;\r\n        }\r\n        this.usedProfilePath = profilePath;\r\n        const profileContent: IConfigFile = JSON.parse(content);\r\n        // replace all pathes in options by absolute paths\r\n        const xliffmergeOptions = profileContent.xliffmergeOptions;\r\n        xliffmergeOptions.srcDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.srcDir);\r\n        xliffmergeOptions.genDir = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.genDir);\r\n        xliffmergeOptions.apikeyfile = this.adjustPathToProfilePath(profilePath, xliffmergeOptions.apikeyfile);\r\n        return profileContent;\r\n    }\r\n\r\n    private adjustPathToProfilePath(profilePath: string, pathToAdjust: string | undefined): string | undefined {\r\n        if (!pathToAdjust || isAbsolute(pathToAdjust)) {\r\n            return pathToAdjust;\r\n        }\r\n        return join(dirname(profilePath), pathToAdjust).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private initializeFromConfig(profileContent: IConfigFile) {\r\n        if (!profileContent) {\r\n            return;\r\n        }\r\n        const profile = profileContent.xliffmergeOptions;\r\n        if (profile) {\r\n            if (!isNullOrUndefined(profile.quiet)) {\r\n                this._quiet = profile.quiet;\r\n            }\r\n            if (!isNullOrUndefined(profile.verbose)) {\r\n                this._verbose = profile.verbose;\r\n            }\r\n            if (!isNullOrUndefined(profile.allowIdChange)) {\r\n                this._allowIdChange = profile.allowIdChange;\r\n            }\r\n            if (profile.defaultLanguage) {\r\n                this._defaultLanguage = profile.defaultLanguage;\r\n            }\r\n            if (profile.languages) {\r\n                this._languages = profile.languages;\r\n            }\r\n            if (profile.srcDir) {\r\n                this._srcDir = profile.srcDir;\r\n            }\r\n            if (profile.angularCompilerOptions) {\r\n                if (profile.angularCompilerOptions.genDir) {\r\n                    this._genDir = profile.angularCompilerOptions.genDir;\r\n                }\r\n            }\r\n            if (profile.genDir) {\r\n                // this must be after angularCompilerOptions to be preferred\r\n                this._genDir = profile.genDir;\r\n            }\r\n            if (profile.i18nBaseFile) {\r\n                this._i18nBaseFile = profile.i18nBaseFile;\r\n            }\r\n            if (profile.i18nFile) {\r\n                this._i18nFile = profile.i18nFile;\r\n            }\r\n            if (profile.i18nFormat) {\r\n                this._i18nFormat = profile.i18nFormat;\r\n            }\r\n            if (profile.encoding) {\r\n                this._encoding = profile.encoding;\r\n            }\r\n            if (!isNullOrUndefined(profile.removeUnusedIds)) {\r\n                this._removeUnusedIds = profile.removeUnusedIds;\r\n            }\r\n            if (!isNullOrUndefined(profile.supportNgxTranslate)) {\r\n                this._supportNgxTranslate = profile.supportNgxTranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.ngxTranslateExtractionPattern)) {\r\n                this._ngxTranslateExtractionPattern = profile.ngxTranslateExtractionPattern;\r\n            }\r\n            if (!isNullOrUndefined(profile.useSourceAsTarget)) {\r\n                this._useSourceAsTarget = profile.useSourceAsTarget;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetPraefix)) {\r\n                this._targetPraefix = profile.targetPraefix;\r\n            }\r\n            if (!isNullOrUndefined(profile.targetSuffix)) {\r\n                this._targetSuffix = profile.targetSuffix;\r\n            }\r\n            if (!isNullOrUndefined(profile.autotranslate)) {\r\n                this._autotranslate = profile.autotranslate;\r\n            }\r\n            if (!isNullOrUndefined(profile.beautifyOutput)) {\r\n                this._beautifyOutput = profile.beautifyOutput;\r\n            }\r\n            if (!isNullOrUndefined(profile.preserveOrder)) {\r\n                this._preserveOrder = profile.preserveOrder;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikey)) {\r\n                this._apikey = profile.apikey;\r\n            }\r\n            if (!isNullOrUndefined(profile.apikeyfile)) {\r\n                this._apikeyfile = profile.apikeyfile;\r\n            }\r\n        } else {\r\n            this.warningsFound.push('did not find \"xliffmergeOptions\" in profile, using defaults');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check all Parameters, wether they are complete and consistent.\r\n     * if something is wrong with the parameters, it is collected in errorsFound.\r\n     */\r\n    private checkParameters(): void {\r\n        this.checkLanguageSyntax(this.defaultLanguage());\r\n        if (this.languages().length === 0) {\r\n            this.errorsFound.push(new XliffMergeError('no languages specified'));\r\n        }\r\n        this.languages().forEach((lang) => {\r\n            this.checkLanguageSyntax(lang);\r\n        });\r\n        let stats: Stats;\r\n        let err: any;\r\n        // srcDir should exists\r\n        try {\r\n            stats = fs.statSync(this.srcDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('srcDir \"' + this.srcDir() + '\" is not a directory'));\r\n        }\r\n        // genDir should exists\r\n        try {\r\n            stats = fs.statSync(this.genDir());\r\n        } catch (e) {\r\n            err = e;\r\n        }\r\n        if (!!err || !stats.isDirectory()) {\r\n            this.errorsFound.push(new XliffMergeError('genDir \"' + this.genDir() + '\" is not a directory'));\r\n        }\r\n        // master file MUST exist\r\n        try {\r\n            fs.accessSync(this.i18nFile(), fs.constants.R_OK);\r\n        } catch (err) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFile \"' + this.i18nFile() + '\" is not readable'));\r\n        }\r\n        // i18nFormat must be xlf xlf2 or xmb\r\n        if (!(this.i18nFormat() === 'xlf' || this.i18nFormat() === 'xlf2' || this.i18nFormat() === 'xmb')) {\r\n            this.errorsFound.push(new XliffMergeError('i18nFormat \"' + this.i18nFormat() + '\" invalid, must be \"xlf\" or \"xlf2\" or \"xmb\"'));\r\n        }\r\n        // autotranslate requires api key\r\n        if (this.autotranslate() && !this.apikey()) {\r\n            this.errorsFound.push(new XliffMergeError('autotranslate requires an API key, please set one'));\r\n        }\r\n        // autotranslated languages must be in list of all languages\r\n        this.autotranslatedLanguages().forEach((lang) => {\r\n            if (this.languages().indexOf(lang) < 0) {\r\n                this.errorsFound.push(new XliffMergeError('autotranslate language \"' + lang + '\" is not in list of languages'));\r\n            }\r\n            if (lang === this.defaultLanguage()) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('autotranslate language \"' + lang + '\" cannot be translated, because it is the source language'));\r\n            }\r\n        });\r\n        // ngx translate pattern check\r\n        if (this.supportNgxTranslate()) {\r\n            const checkResult = NgxTranslateExtractor.checkPattern(this.ngxTranslateExtractionPattern());\r\n            if (!isNullOrUndefined(checkResult)) {\r\n                this.errorsFound.push(\r\n                    new XliffMergeError('ngxTranslateExtractionPattern \"' + this.ngxTranslateExtractionPattern() + '\": ' + checkResult));\r\n            }\r\n        }\r\n        // targetPraefix and targetSuffix check\r\n        if (!this.useSourceAsTarget()) {\r\n            if (this.targetPraefix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetPraefix \"' + this.targetPraefix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n            if (this.targetSuffix().length > 0) {\r\n                this.warningsFound.push(\r\n                    'configured targetSuffix \"' + this.targetSuffix() + '\" will not be used because \"useSourceAsTarget\" is disabled\"');\r\n            }\r\n        }\r\n     }\r\n\r\n    /**\r\n     * Check syntax of language.\r\n     * Must be compatible with XML Schema type xsd:language.\r\n     * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*\r\n     * @param lang language to check\r\n     */\r\n    private checkLanguageSyntax(lang: string) {\r\n        const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;\r\n        if (!pattern.test(lang)) {\r\n            this.errorsFound.push(new XliffMergeError('language \"' + lang + '\" is not valid'));\r\n        }\r\n    }\r\n\r\n    public allowIdChange(): boolean {\r\n        return (isNullOrUndefined(this._allowIdChange)) ? false : this._allowIdChange;\r\n    }\r\n\r\n    public verbose(): boolean {\r\n        return (isNullOrUndefined(this._verbose)) ? false : this._verbose;\r\n    }\r\n\r\n    public quiet(): boolean {\r\n        return (isNullOrUndefined(this._quiet)) ? false : this._quiet;\r\n    }\r\n\r\n    /**\r\n     * Debug output all parameters to commandOutput.\r\n     */\r\n    public showAllParameters(commandOutput: CommandOutput): void {\r\n        commandOutput.debug('xliffmerge Used Parameters:');\r\n        commandOutput.debug('usedProfilePath:\\t\"%s\"', this.usedProfilePath);\r\n        commandOutput.debug('defaultLanguage:\\t\"%s\"', this.defaultLanguage());\r\n        commandOutput.debug('srcDir:\\t\"%s\"', this.srcDir());\r\n        commandOutput.debug('genDir:\\t\"%s\"', this.genDir());\r\n        commandOutput.debug('i18nBaseFile:\\t\"%s\"', this.i18nBaseFile());\r\n        commandOutput.debug('i18nFile:\\t\"%s\"', this.i18nFile());\r\n        commandOutput.debug('languages:\\t%s', this.languages());\r\n        for (const language of this.languages()) {\r\n            commandOutput.debug('outputFile[%s]:\\t%s', language, this.generatedI18nFile(language));\r\n        }\r\n        commandOutput.debug('removeUnusedIds:\\t%s', this.removeUnusedIds());\r\n        commandOutput.debug('supportNgxTranslate:\\t%s', this.supportNgxTranslate());\r\n        if (this.supportNgxTranslate()) {\r\n            commandOutput.debug('ngxTranslateExtractionPattern:\\t%s', this.ngxTranslateExtractionPattern());\r\n        }\r\n        commandOutput.debug('useSourceAsTarget:\\t%s', this.useSourceAsTarget());\r\n        if (this.useSourceAsTarget()) {\r\n            commandOutput.debug('targetPraefix:\\t\"%s\"', this.targetPraefix());\r\n            commandOutput.debug('targetSuffix:\\t\"%s\"', this.targetSuffix());\r\n        }\r\n        commandOutput.debug('allowIdChange:\\t%s', this.allowIdChange());\r\n        commandOutput.debug('beautifyOutput:\\t%s', this.beautifyOutput());\r\n        commandOutput.debug('preserveOrder:\\t%s', this.preserveOrder());\r\n        commandOutput.debug('autotranslate:\\t%s', this.autotranslate());\r\n        if (this.autotranslate()) {\r\n            commandOutput.debug('autotranslated languages:\\t%s', this.autotranslatedLanguages());\r\n            commandOutput.debug('apikey:\\t%s', this.apikey() ? '****' : 'NOT SET');\r\n            commandOutput.debug('apikeyfile:\\t%s', this.apikeyfile());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default-Language, default en.\r\n     * @return default language\r\n     */\r\n    public defaultLanguage(): string {\r\n        return this._defaultLanguage ? this._defaultLanguage : 'en';\r\n    }\r\n\r\n    /**\r\n     * Liste der zu bearbeitenden Sprachen.\r\n     * @return languages\r\n     */\r\n    public languages(): string[] {\r\n        return this._languages ? this._languages : [];\r\n    }\r\n\r\n    /**\r\n     * src directory, where the master xlif is located.\r\n     * @return srcDir\r\n     */\r\n    public srcDir(): string {\r\n        return this._srcDir ? this._srcDir : '.';\r\n    }\r\n\r\n    /**\r\n     * The base file name of the xlif file for input and output.\r\n     * Default is messages\r\n     * @return base file\r\n     */\r\n    public i18nBaseFile(): string {\r\n        return this._i18nBaseFile ? this._i18nBaseFile : 'messages';\r\n    }\r\n\r\n    /**\r\n     * The master xlif file (the one generated by ng-xi18n).\r\n     * Default is <srcDir>/<i18nBaseFile>.xlf.\r\n     * @return master file\r\n     */\r\n    public i18nFile(): string {\r\n        return join(this.srcDir(),\r\n            (this._i18nFile ? this._i18nFile : this.i18nBaseFile() + '.' + this.suffixForGeneratedI18nFile())\r\n        ).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * Format of the master xlif file.\r\n     * Default is \"xlf\", possible are \"xlf\" or \"xlf2\" or \"xmb\".\r\n     * @return format\r\n     */\r\n    public i18nFormat(): string {\r\n        return (this._i18nFormat ? this._i18nFormat : 'xlf');\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated I18n-File with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + this.suffixForGeneratedI18nFile()).replace(/\\\\/g, '/');\r\n    }\r\n\r\n    private suffixForGeneratedI18nFile(): string {\r\n        switch (this.i18nFormat()) {\r\n            case 'xlf':\r\n                return 'xlf';\r\n            case 'xlf2':\r\n                return 'xlf';\r\n            case 'xmb':\r\n                return 'xtb';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * potentially to be generated translate-File for ngx-translate with the translations for one language.\r\n     * @param lang language shortcut\r\n     * @return Path of file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return join(this.genDir(), this.i18nBaseFile() + '.' + lang + '.' + 'json').replace(/\\\\/g, '/');\r\n    }\r\n\r\n    /**\r\n     * The encoding used to write new XLIFF-files.\r\n     * @return encoding\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding ? this._encoding : 'UTF-8';\r\n    }\r\n\r\n     /**\r\n      * Output-Directory, where the output is written to.\r\n      * Default is <srcDir>.\r\n     */\r\n    public genDir(): string {\r\n        return this._genDir ? this._genDir : this.srcDir();\r\n    }\r\n\r\n    public removeUnusedIds(): boolean {\r\n        return (isNullOrUndefined(this._removeUnusedIds)) ? true : this._removeUnusedIds;\r\n    }\r\n\r\n    public supportNgxTranslate(): boolean {\r\n        return (isNullOrUndefined(this._supportNgxTranslate)) ? false : this._supportNgxTranslate;\r\n    }\r\n\r\n    public ngxTranslateExtractionPattern(): string {\r\n        return (isNullOrUndefined(this._ngxTranslateExtractionPattern)) ?\r\n            NgxTranslateExtractor.DefaultExtractionPattern : this._ngxTranslateExtractionPattern;\r\n    }\r\n\r\n    /**\r\n     * Whether source must be used as target for new trans-units\r\n     * Default is true\r\n     */\r\n    public useSourceAsTarget(): boolean {\r\n        return (isNullOrUndefined(this._useSourceAsTarget)) ? true : this._useSourceAsTarget;\r\n    }\r\n\r\n    /**\r\n     * Praefix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetPraefix(): string {\r\n        return (isNullOrUndefined(this._targetPraefix)) ? '' : this._targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Suffix used for target when copying new trans-units\r\n     * Default is \"\"\r\n     */\r\n    public targetSuffix(): string {\r\n        return (isNullOrUndefined(this._targetSuffix)) ? '' : this._targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * If set, run xml result through beautifier (pretty-data).\r\n     */\r\n    public beautifyOutput(): boolean {\r\n        return (isNullOrUndefined(this._beautifyOutput)) ? false : this._beautifyOutput;\r\n    }\r\n\r\n    /**\r\n     * If set, order of new trans units will be as in master.\r\n     * Otherwise they are added at the end.\r\n     */\r\n    public preserveOrder(): boolean {\r\n        return (isNullOrUndefined(this._preserveOrder)) ? true : this._preserveOrder;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for new trans-units\r\n     * Default is false\r\n     */\r\n    public autotranslate(): boolean {\r\n        if (isNullOrUndefined(this._autotranslate)) {\r\n            return false;\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate).length > 0;\r\n        }\r\n        return <boolean> this._autotranslate;\r\n    }\r\n\r\n    /**\r\n     * Whether to use autotranslate for a given language.\r\n     * @param lang language code.\r\n     */\r\n    public autotranslateLanguage(lang: string): boolean {\r\n        return this.autotranslatedLanguages().indexOf(lang) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Return a list of languages to be autotranslated.\r\n     */\r\n    public autotranslatedLanguages(): string[] {\r\n        if (isNullOrUndefined(this._autotranslate) || this._autotranslate === false) {\r\n            return [];\r\n        }\r\n        if (isArray(this._autotranslate)) {\r\n            return (<string[]>this._autotranslate);\r\n        }\r\n        return this.languages().slice(1); // first is source language\r\n    }\r\n\r\n    /**\r\n     * API key to be used for Google Translate\r\n     * @return api key\r\n     */\r\n    public apikey(): string {\r\n        if (!isNullOrUndefined(this._apikey)) {\r\n            return this._apikey;\r\n        } else {\r\n            const apikeyPath = this.apikeyfile();\r\n            if (this.apikeyfile()) {\r\n                if (fs.existsSync(apikeyPath)) {\r\n                    return FileUtil.read(apikeyPath, 'utf-8');\r\n                } else {\r\n                    throw new Error(format('api key file not found: API_KEY_FILE=%s', apikeyPath));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * file name for API key to be used for Google Translate.\r\n     * Explicitly set or read from env var API_KEY_FILE.\r\n     * @return file of api key\r\n     */\r\n    public apikeyfile(): string {\r\n        if (this._apikeyfile) {\r\n            return this._apikeyfile;\r\n        } else if (process.env.API_KEY_FILE) {\r\n            return process.env.API_KEY_FILE;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 19.02.2017.\r\n */\r\nimport * as path from 'path';\r\n\r\nlet pkg = null;\r\ntry {\r\n    pkg = require(path.resolve(__dirname, '..', 'package.json'));\r\n} catch (e) {\r\n    try {\r\n        pkg = require(path.resolve(__dirname, '..', '..', 'package.json'));\r\n    } catch (e) {\r\n        pkg = null;\r\n    }\r\n}\r\n\r\nexport const VERSION = (pkg ? pkg.version : 'unknown');\r\n","import {FileUtil} from '../common/file-util';\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * Helper class to read XMl with a correct encoding.\r\n */\r\n\r\nexport class XmlReader {\r\n    static DEFAULT_ENCODING = 'UTF-8';\r\n\r\n    /**\r\n     * Read an xml-File.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return file content and encoding found in the file.\r\n     */\r\n    public static readXmlFileContent(path: string, encoding?: string): {content: string, encoding: string} {\r\n        if (!encoding) {\r\n            encoding = XmlReader.DEFAULT_ENCODING;\r\n        }\r\n        let content: string = FileUtil.read(path, encoding);\r\n        const foundEncoding = XmlReader.encodingFromXml(content);\r\n        if (foundEncoding !== encoding) {\r\n            // read again with the correct encoding\r\n            content = FileUtil.read(path, foundEncoding);\r\n        }\r\n        return {\r\n            content: content,\r\n            encoding: foundEncoding\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Read the encoding from the xml.\r\n     * xml File starts with .. encoding=\"..\"\r\n     * @param xmlString xmlString\r\n     * @return encoding\r\n     */\r\n    private static encodingFromXml(xmlString: string): string {\r\n        const index = xmlString.indexOf('encoding=\"');\r\n        if (index < 0) {\r\n            return this.DEFAULT_ENCODING; // default in xml if not explicitly set\r\n        }\r\n        const endIndex = xmlString.indexOf('\"', index + 10); // 10 = length of 'encoding=\"'\r\n        return xmlString.substring(index + 10, endIndex);\r\n    }\r\n\r\n}\r\n\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {TranslationMessagesFileFactory, ITranslationMessagesFile} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {XmlReader} from './xml-reader';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n */\r\nexport class TranslationMessagesFileReader {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat format\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromFile(i18nFormat: string,\r\n                           path: string,\r\n                           encoding: string,\r\n                           optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromFileContent(i18nFormat, xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @return XliffFile\r\n     */\r\n    public static fromUnknownFormatFile(path: string,\r\n                                        encoding: string,\r\n                                        optionalMasterFilePath?: string): ITranslationMessagesFile {\r\n        const xmlContent = XmlReader.readXmlFileContent(path, encoding);\r\n        const optionalMaster = TranslationMessagesFileReader.masterFileContent(optionalMasterFilePath, encoding);\r\n        return TranslationMessagesFileFactory.fromUnknownFormatFileContent(xmlContent.content, path, xmlContent.encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read master xmb file\r\n     * @param optionalMasterFilePath optionalMasterFilePath\r\n     * @param encoding encoding\r\n     * @return content and encoding of file\r\n     */\r\n    private static masterFileContent(optionalMasterFilePath: string, encoding: string)\r\n        : {xmlContent: string, path: string, encoding: string} {\r\n        if (optionalMasterFilePath) {\r\n            const masterXmlContent = XmlReader.readXmlFileContent(optionalMasterFilePath, encoding);\r\n            return {\r\n                xmlContent: masterXmlContent.content,\r\n                path: optionalMasterFilePath,\r\n                encoding: masterXmlContent.encoding\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save edited file.\r\n     * @param messagesFile messagesFile\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public static save(messagesFile: ITranslationMessagesFile, beautifyOutput?: boolean) {\r\n        FileUtil.replaceContent(messagesFile.filename(), messagesFile.editedContent(beautifyOutput), messagesFile.encoding());\r\n    }\r\n}\r\n\r\n","import {format} from 'util';\r\nimport * as request from 'request';\r\nimport {Observable} from 'rxjs';\r\nimport {of, forkJoin, throwError} from 'rxjs';\r\nimport {map} from 'rxjs/operators';\r\n\r\n/**\r\n * Created by roobm on 03.07.2017.\r\n * Low Level Service to call Google Translate.\r\n */\r\n\r\n/**\r\n * Types form google translate api.\r\n */\r\n\r\ninterface GetSupportedLanguagesRequest {\r\n    target: string; // The language to use to return localized, human readable names of supported\\nlanguages.\r\n}\r\n\r\ninterface LanguagesResource {\r\n    language: string; // code of the language\r\n    name: string; // human readable name (in target language)\r\n}\r\n\r\ninterface LanguagesListResponse {\r\n    languages: LanguagesResource[];\r\n}\r\n\r\ninterface TranslateTextRequest {\r\n    q: string[];  // The input texts to translate\r\n    target: string; // The language to use for translation of the input text\r\n    source: string; // The language of the source text\r\n    format?: string; // \"html\" (default) or \"text\"\r\n    model?: string; // see public documentation\r\n}\r\n\r\ninterface TranslationsResource {\r\n    detectedSourceLanguage?: string;\r\n    model?: string;\r\n    translatedText: string;\r\n}\r\n\r\ninterface TranslationsListResponse {\r\n    translations: TranslationsResource[];\r\n}\r\n\r\ninterface InternalRequestResponse {\r\n    response: request.RequestResponse;\r\n    body: any;\r\n}\r\n\r\nconst MAX_SEGMENTS = 128;\r\n\r\nexport class AutoTranslateService {\r\n\r\n    private _request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;\r\n    _rootUrl: string;\r\n    _apiKey: string;\r\n\r\n    /**\r\n     * Strip region code and convert to lower\r\n     * @param lang lang\r\n     * @return lang without region code and in lower case.\r\n     */\r\n    public static stripRegioncode(lang: string): string {\r\n        const langLower = lang.toLowerCase();\r\n        for (let i = 0; i < langLower.length; i++) {\r\n            const c = langLower.charAt(i);\r\n            if (c < 'a' || c > 'z') {\r\n                return langLower.substring(0, i);\r\n            }\r\n        }\r\n        return langLower;\r\n    }\r\n\r\n    constructor(apiKey: string) {\r\n        this._request = request;\r\n        this._apiKey = apiKey;\r\n        this._rootUrl = 'https://translation.googleapis.com/';\r\n    }\r\n\r\n    /**\r\n     * Change API key (just for tests).\r\n     * @param apikey apikey\r\n     */\r\n    public setApiKey(apikey: string) {\r\n        this._apiKey = apikey;\r\n    }\r\n\r\n    /**\r\n     * Translate an array of messages at once.\r\n     * @param messages the messages to be translated\r\n     * @param from source language code\r\n     * @param to target language code\r\n     * @return Observable with translated messages or error\r\n     */\r\n    public translateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        // empty array needs no translation and always works ... (#78)\r\n        if (messages.length === 0) {\r\n            return of([]);\r\n        }\r\n        if (!this._apiKey) {\r\n            return throwError('cannot autotranslate: no api key');\r\n        }\r\n        if (!from || !to) {\r\n            return throwError('cannot autotranslate: source and target language must be set');\r\n        }\r\n        from = AutoTranslateService.stripRegioncode(from);\r\n        to = AutoTranslateService.stripRegioncode(to);\r\n        const allRequests: Observable<string[]>[] = this.splitMessagesToGoogleLimit(messages).map((partialMessages: string[]) => {\r\n            return this.limitedTranslateMultipleStrings(partialMessages, from, to);\r\n        });\r\n        return forkJoin(allRequests).pipe(\r\n            map((allTranslations: string[][]) => {\r\n                let all = [];\r\n                for (let i = 0; i < allTranslations.length; i++) {\r\n                    all = all.concat(allTranslations[i]);\r\n                }\r\n                return all;\r\n        }));\r\n    }\r\n\r\n    private splitMessagesToGoogleLimit(messages: string[]): string[][] {\r\n        if (messages.length <= MAX_SEGMENTS) {\r\n            return [messages];\r\n        }\r\n        const result = [];\r\n        let currentPackage = [];\r\n        let packageSize = 0;\r\n        for (let i = 0; i < messages.length; i++) {\r\n            currentPackage.push(messages[i]);\r\n            packageSize++;\r\n            if (packageSize >= MAX_SEGMENTS) {\r\n                result.push(currentPackage);\r\n                currentPackage = [];\r\n                packageSize = 0;\r\n            }\r\n        }\r\n        if (currentPackage.length > 0) {\r\n            result.push(currentPackage);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return translation request, but messages must be limited to google limits.\r\n     * Not more that 128 single messages.\r\n     * @param messages messages\r\n     * @param from from\r\n     * @param to to\r\n     * @return the translated strings\r\n     */\r\n    private limitedTranslateMultipleStrings(messages: string[], from: string, to: string): Observable<string[]> {\r\n        const realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;\r\n        const translateRequest: TranslateTextRequest = {\r\n            q: messages,\r\n            target: to,\r\n            source: from,\r\n        };\r\n        const options = {\r\n            url: realUrl,\r\n            body: translateRequest,\r\n            json: true,\r\n//            proxy: 'http://127.0.0.1:8888' To set a proxy use env var HTTPS_PROXY\r\n        };\r\n        return this.post(realUrl, options).pipe(\r\n            map((data) => {\r\n            const body: any = data.body;\r\n            if (!body) {\r\n                throw new Error('no result received');\r\n            }\r\n            if (body.error) {\r\n                if (body.error.code === 400) {\r\n                    if (body.error.message === 'Invalid Value') {\r\n                        throw new Error(format('Translation from \"%s\" to \"%s\" not supported', from, to));\r\n                    }\r\n                    throw new Error(format('Invalid request: %s', body.error.message));\r\n                } else {\r\n                    throw new Error(format('Error %s: %s', body.error.code, body.error.message));\r\n                }\r\n            }\r\n            const result = body.data;\r\n            return result.translations.map((translation: TranslationsResource) => {\r\n                return translation.translatedText;\r\n            });\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Function to do a POST HTTP request\r\n     *\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     */\r\n    post(uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> this._call.apply(this, [].concat('post', <string> uri,\r\n            <request.CoreOptions> Object.assign({}, options || {})));\r\n    }\r\n\r\n    /**\r\n     * Function to do a HTTP request for given method\r\n     *\r\n     * @param method method\r\n     * @param uri uri\r\n     * @param options options\r\n     *\r\n     * @return response\r\n     *\r\n     */\r\n    private _call(method: string, uri: string, options?: request.CoreOptions): Observable<InternalRequestResponse> {\r\n        return <Observable<InternalRequestResponse>> Observable.create((observer) => {\r\n            // build params array\r\n            const params = [].concat(<string> uri, <request.CoreOptions> Object.assign({}, options || {}),\r\n                <RequestCallback>(error: any, response: request.RequestResponse, body: any) => {\r\n                    if (error) {\r\n                        return observer.error(error);\r\n                    }\r\n\r\n                    observer.next(<InternalRequestResponse> Object.assign({}, {\r\n                        response: <request.RequestResponse> response,\r\n                        body: <any> body\r\n                    }));\r\n                    observer.complete();\r\n                });\r\n\r\n            // _call request method\r\n            try {\r\n                this._request[<string> method].apply(\r\n                    <request.RequestAPI<request.Request,\r\n                    request.CoreOptions,\r\n                    request.RequiredUriUrl>> this._request,\r\n                    params);\r\n            } catch (error) {\r\n                observer.error(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateResult {\r\n\r\n  constructor(private _success: boolean, private _details: string) {\r\n\r\n  }\r\n\r\n  public success(): boolean {\r\n    return this._success;\r\n  }\r\n}\r\n","import {AutoTranslateResult} from './auto-translate-result';\r\nimport {format} from 'util';\r\nimport {ITransUnit} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\n\r\n/**\r\n * A report about a run of Google Translate over all untranslated unit.\r\n * * Created by martin on 29.06.2017.\r\n */\r\n\r\nexport class AutoTranslateSummaryReport {\r\n\r\n  private _error: string;\r\n  private _from: string;\r\n  private _to: string;\r\n  private _total: number;\r\n  private _ignored: number;\r\n  private _success: number;\r\n  private _failed: number;\r\n\r\n  constructor(from: string, to: string) {\r\n    this._from = from;\r\n    this._to = to;\r\n    this._total = 0;\r\n    this._ignored = 0;\r\n    this._success = 0;\r\n    this._failed = 0;\r\n  }\r\n\r\n  /**\r\n   * Set error if total call failed (e.g. \"invalid api key\" or \"no connection\" ...)\r\n   * @param error error\r\n   * @param total total\r\n   */\r\n  public setError(error: string, total: number) {\r\n    this._error = error;\r\n    this._total = total;\r\n    this._failed = total;\r\n  }\r\n\r\n  public error(): string {\r\n    return this._error;\r\n  }\r\n\r\n  public setIgnored(ignored: number) {\r\n    this._total += ignored;\r\n    this._ignored = ignored;\r\n  }\r\n\r\n  /**\r\n   * Add a single result to the summary.\r\n   * @param tu tu\r\n   * @param result result\r\n   */\r\n  public addSingleResult(tu: ITransUnit, result: AutoTranslateResult) {\r\n    this._total++;\r\n    if (result.success()) {\r\n      this._success++;\r\n    } else {\r\n      this._failed++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge another summary into this one.\r\n   * @param anotherSummary anotherSummary\r\n   */\r\n  public merge(anotherSummary: AutoTranslateSummaryReport) {\r\n    if (!this._error) {\r\n      this._error = anotherSummary._error;\r\n    }\r\n    this._total += anotherSummary.total();\r\n    this._ignored += anotherSummary.ignored();\r\n    this._success += anotherSummary.success();\r\n    this._failed += anotherSummary.failed();\r\n  }\r\n\r\n  public total(): number {\r\n    return this._total;\r\n  }\r\n\r\n  public ignored(): number {\r\n    return this._ignored;\r\n  }\r\n\r\n  public success(): number {\r\n    return this._success;\r\n  }\r\n\r\n  public failed(): number {\r\n    return this._failed;\r\n  }\r\n\r\n  /**\r\n   * Human readable version of report\r\n   */\r\n  public content(): string {\r\n    let result;\r\n    if (this._error) {\r\n      result = format('Auto translation from \"%s\" to \"%s\" failed: \"%s\", failed units: %s', this._from, this._to, this._error, this._failed);\r\n    } else {\r\n      result = format('Auto translation from \"%s\" to \"%s\", total auto translated units: %s, ignored: %s, succesful: %s, failed: %s',\r\n          this._from, this._to, this._total, this._ignored, this._success, this._failed);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","import {isNullOrUndefined} from '../common/util';\r\nimport {Observable, forkJoin, of} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport * as entityDecoderLib from 'he';\r\nimport {\r\n    IICUMessage, IICUMessageTranslation, INormalizedMessage, ITranslationMessagesFile, ITransUnit,\r\n    STATE_NEW\r\n} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {AutoTranslateService} from './auto-translate-service';\r\nimport {AutoTranslateResult} from './auto-translate-result';\r\nimport {AutoTranslateSummaryReport} from './auto-translate-summary-report';\r\n/**\r\n * Created by martin on 07.07.2017.\r\n * Service to autotranslate Transunits via Google Translate.\r\n */\r\n\r\nexport class XliffMergeAutoTranslateService {\r\n\r\n    private autoTranslateService: AutoTranslateService;\r\n\r\n    constructor(apikey: string) {\r\n        this.autoTranslateService = new AutoTranslateService(apikey);\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    public autoTranslate(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        return forkJoin([\r\n            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile),\r\n            ...this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)])\r\n            .pipe(\r\n                map((summaries: AutoTranslateSummaryReport[]) => {\r\n                    const summary = summaries[0];\r\n                    for (let i = 1; i < summaries.length; i++) {\r\n                        summary.merge(summaries[i]);\r\n                    }\r\n                    return summary;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Collect all units that are untranslated.\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return all untranslated units\r\n     */\r\n    private allUntranslatedTUs(languageSpecificMessagesFile: ITranslationMessagesFile): ITransUnit[] {\r\n        // collect all units, that should be auto translated\r\n        const allUntranslated: ITransUnit[] = [];\r\n        languageSpecificMessagesFile.forEachTransUnit((tu) => {\r\n            if (tu.targetState() === STATE_NEW) {\r\n                allUntranslated.push(tu);\r\n            }\r\n        });\r\n        return allUntranslated;\r\n    }\r\n\r\n    private doAutoTranslateNonICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport> {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatable = allUntranslated.filter((tu) => isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        const allMessages: string[] = allTranslatable.map((tu) => {\r\n            return tu.sourceContentNormalized().asDisplayString();\r\n        });\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                const summary = new AutoTranslateSummaryReport(from, to);\r\n                summary.setIgnored(allUntranslated.length - allTranslatable.length);\r\n                for (let i = 0; i < translations.length; i++) {\r\n                    const tu = allTranslatable[i];\r\n                    const translationText = translations[i];\r\n                    const result = this.autoTranslateNonICUUnit(tu, translationText);\r\n                    summary.addSingleResult(tu, result);\r\n                }\r\n                return summary;\r\n                }),\r\n                catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private doAutoTranslateICUMessages(from: string, to: string, languageSpecificMessagesFile: ITranslationMessagesFile)\r\n        : Observable<AutoTranslateSummaryReport>[] {\r\n        const allUntranslated: ITransUnit[] = this.allUntranslatedTUs(languageSpecificMessagesFile);\r\n        const allTranslatableICU = allUntranslated.filter((tu) => !isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()));\r\n        return allTranslatableICU.map((tu) => {\r\n            return this.doAutoTranslateICUMessage(from, to, tu);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Translate single ICU Messages.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tu transunit to translate (must contain ICU Message)\r\n     * @return summary report\r\n     */\r\n    private doAutoTranslateICUMessage(from: string, to: string, tu: ITransUnit): Observable<AutoTranslateSummaryReport> {\r\n        const icuMessage: IICUMessage = tu.sourceContentNormalized().getICUMessage();\r\n        const categories = icuMessage.getCategories();\r\n        // check for nested ICUs, we do not support that\r\n        if (categories.find((category) => !isNullOrUndefined(category.getMessageNormalized().getICUMessage()))) {\r\n            const summary = new AutoTranslateSummaryReport(from, to);\r\n            summary.setIgnored(1);\r\n            return of(summary);\r\n        }\r\n        const allMessages: string[] = categories.map((category) => category.getMessageNormalized().asDisplayString());\r\n        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)\r\n            .pipe(\r\n                // #94 google translate might return &#.. entity refs, that must be decoded\r\n                map((translations: string[]) => translations.map(encodedTranslation => entityDecoderLib.decode(encodedTranslation))),\r\n                map((translations: string[]) => {\r\n                    const summary = new AutoTranslateSummaryReport(from, to);\r\n                    const icuTranslation: IICUMessageTranslation = {};\r\n                    for (let i = 0; i < translations.length; i++) {\r\n                        icuTranslation[categories[i].getCategory()] = translations[i];\r\n                    }\r\n                    const result = this.autoTranslateICUUnit(tu, icuTranslation);\r\n                    summary.addSingleResult(tu, result);\r\n                    return summary;\r\n                }), catchError((err) => {\r\n                    const failSummary = new AutoTranslateSummaryReport(from, to);\r\n                    failSummary.setError(err.message, allMessages.length);\r\n                    return of(failSummary);\r\n            }));\r\n    }\r\n\r\n    private autoTranslateNonICUUnit(tu: ITransUnit, translatedMessage: string): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));\r\n    }\r\n\r\n    private autoTranslateICUUnit(tu: ITransUnit, translation: IICUMessageTranslation): AutoTranslateResult {\r\n        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));\r\n    }\r\n\r\n    private autoTranslateUnit(tu: ITransUnit, translatedMessage: INormalizedMessage): AutoTranslateResult {\r\n        const errors = translatedMessage.validate();\r\n        const warnings = translatedMessage.validateWarnings();\r\n        if (!isNullOrUndefined(errors)) {\r\n            return new AutoTranslateResult(false, 'errors detected, not translated');\r\n        } else if (!isNullOrUndefined(warnings)) {\r\n            return new AutoTranslateResult(false, 'warnings detected, not translated');\r\n        } else {\r\n            tu.translate(translatedMessage);\r\n            return new AutoTranslateResult(true, null); // success\r\n        }\r\n    }\r\n}\r\n","import {CommandOutput} from '../common/command-output';\r\nimport {XliffMergeParameters} from './xliff-merge-parameters';\r\nimport {XliffMergeError} from './xliff-merge-error';\r\nimport {FileUtil} from '../common/file-util';\r\nimport {VERSION} from './version';\r\nimport {format} from 'util';\r\nimport {isNullOrUndefined} from '../common/util';\r\nimport {ITranslationMessagesFile, ITransUnit,\r\n    FORMAT_XMB, FORMAT_XTB,\r\n    NORMALIZATION_FORMAT_DEFAULT, STATE_FINAL, STATE_TRANSLATED} from '@ngx-i18nsupport/ngx-i18nsupport-lib';\r\nimport {ProgramOptions, IConfigFile} from './i-xliff-merge-options';\r\nimport {NgxTranslateExtractor} from './ngx-translate-extractor';\r\nimport {TranslationMessagesFileReader} from './translation-messages-file-reader';\r\nimport {Observable, of, forkJoin} from 'rxjs';\r\nimport {map, catchError} from 'rxjs/operators';\r\nimport {XliffMergeAutoTranslateService} from '../autotranslate/xliff-merge-auto-translate-service';\r\nimport {AutoTranslateSummaryReport} from '../autotranslate/auto-translate-summary-report';\r\n\r\n/**\r\n * Created by martin on 17.02.2017.\r\n * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.\r\n *\r\n */\r\n\r\nexport class XliffMerge {\r\n\r\n    private readonly commandOutput: CommandOutput;\r\n\r\n    private readonly options: ProgramOptions;\r\n\r\n    private parameters: XliffMergeParameters;\r\n\r\n    /**\r\n     * The read master xlf file.\r\n     */\r\n    private master: ITranslationMessagesFile; // XliffFile or Xliff2File or XmbFile\r\n\r\n    private autoTranslateService: XliffMergeAutoTranslateService;\r\n\r\n    static main(argv: string[]) {\r\n        const options = XliffMerge.parseArgs(argv);\r\n        if (options) {\r\n            new XliffMerge(new CommandOutput(process.stdout), options).run((result) => {\r\n                process.exit(result);\r\n            });\r\n        }\r\n    }\r\n\r\n    static parseArgs(argv: string[]): ProgramOptions {\r\n        const options: ProgramOptions = {\r\n            languages: []\r\n        };\r\n        for (let i = 1; i < argv.length; i++) {\r\n            const arg = argv[i];\r\n            if (arg === '--version' || arg === '-version') {\r\n                console.log('xliffmerge ' + VERSION);\r\n            } else if (arg === '--verbose' || arg === '-v') {\r\n                options.verbose = true;\r\n            } else if (arg === '--profile' || arg === '-p') {\r\n                i++;\r\n                if (i >= argv.length) {\r\n                    console.log('missing config file');\r\n                    XliffMerge.showUsage();\r\n                    return null;\r\n                } else {\r\n                    options.profilePath = argv[i];\r\n                }\r\n            } else if (arg === '--quiet' || arg === '-q') {\r\n                options.quiet = true;\r\n            } else if (arg === '--help' || arg === '-help' || arg === '-h') {\r\n                XliffMerge.showUsage();\r\n            } else if (arg.length > 0 && arg.charAt(0) === '-') {\r\n                console.log('unknown option');\r\n                return null;\r\n            } else {\r\n                options.languages.push(arg);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n\r\n    static showUsage() {\r\n        console.log('usage: xliffmerge <option>* <language>*');\r\n        console.log('Options');\r\n        console.log('\\t-p|--profile a json configuration file containing all relevant parameters.');\r\n        console.log('\\t\\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');\r\n        console.log('\\t-v|--verbose show some output for debugging purposes');\r\n        console.log('\\t-q|--quiet only show errors, nothing else');\r\n        console.log('\\t-version|--version show version string');\r\n        console.log('');\r\n        console.log('\\t<language> has to be a valid language short string, e,g. \"en\", \"de\", \"de-ch\"');\r\n    }\r\n\r\n    /**\r\n     * For Tests, create instance with given profile\r\n     * @param commandOutput commandOutput\r\n     * @param options options\r\n     * @param profileContent profileContent\r\n     */\r\n    public static createFromOptions(commandOutput: CommandOutput, options: ProgramOptions, profileContent?: IConfigFile) {\r\n        const instance = new XliffMerge(commandOutput, options);\r\n        instance.parameters = XliffMergeParameters.createFromOptions(options, profileContent);\r\n        return instance;\r\n    }\r\n\r\n    constructor(commandOutput: CommandOutput, options: ProgramOptions) {\r\n        this.commandOutput = commandOutput;\r\n        this.options = options;\r\n        this.parameters = null;\r\n    }\r\n\r\n    /**\r\n     * Run the command.\r\n     * This runs async.\r\n     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.\r\n     * @param errorFunction callbackFunction for error handling\r\n     */\r\n    public run(callbackFunction?: ((retcode: number) => any), errorFunction?: ((error: any) => any)) {\r\n        this.runAsync()\r\n            .subscribe((retcode: number) => {\r\n                if (!isNullOrUndefined(callbackFunction)) {\r\n                    callbackFunction(retcode);\r\n                }\r\n            }, (error) => {\r\n                if (!isNullOrUndefined(errorFunction)) {\r\n                    errorFunction(error);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Execute merge-Process.\r\n     * @return Async operation, on completion returns retcode 0=ok, other = error.\r\n     */\r\n    public runAsync(): Observable<number> {\r\n        if (this.options && this.options.quiet) {\r\n            this.commandOutput.setQuiet();\r\n        }\r\n        if (this.options && this.options.verbose) {\r\n            this.commandOutput.setVerbose();\r\n        }\r\n        if (!this.parameters) {\r\n            this.parameters = XliffMergeParameters.createFromOptions(this.options);\r\n        }\r\n        this.commandOutput.info('xliffmerge version %s', VERSION);\r\n        if (this.parameters.verbose()) {\r\n            this.parameters.showAllParameters(this.commandOutput);\r\n        }\r\n        if (this.parameters.errorsFound.length > 0) {\r\n            for (const err of this.parameters.errorsFound) {\r\n                this.commandOutput.error(err.message);\r\n            }\r\n            return of(-1);\r\n        }\r\n        if (this.parameters.warningsFound.length > 0) {\r\n            for (const warn of this.parameters.warningsFound) {\r\n                this.commandOutput.warn(warn);\r\n            }\r\n        }\r\n        this.readMaster();\r\n        if (this.parameters.autotranslate()) {\r\n            this.autoTranslateService = new XliffMergeAutoTranslateService(this.parameters.apikey());\r\n        }\r\n        const executionForAllLanguages: Observable<number>[] = [];\r\n        this.parameters.languages().forEach((lang: string) => {\r\n            executionForAllLanguages.push(this.processLanguage(lang));\r\n        });\r\n        return forkJoin(executionForAllLanguages).pipe(\r\n            map((retcodes: number[]) => this.totalRetcode(retcodes)));\r\n    }\r\n\r\n    /**\r\n     * Give an array of retcodes for the different languages, return the total retcode.\r\n     * If all are 0, it is 0, otherwise the first non zero.\r\n     * @param retcodes retcodes\r\n     * @return number\r\n     */\r\n    private totalRetcode(retcodes: number[]): number {\r\n        for (let i = 0; i < retcodes.length; i++) {\r\n            if (retcodes[i] !== 0) {\r\n                return retcodes[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated file for given lang.\r\n     * @param lang language\r\n     * @return name of generated file\r\n     */\r\n    public generatedI18nFile(lang: string): string {\r\n        return this.parameters.generatedI18nFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Return the name of the generated ngx-translation file for given lang.\r\n     * @param lang language\r\n     * @return name of translate file\r\n     */\r\n    public generatedNgxTranslateFile(lang: string): string {\r\n        return this.parameters.generatedNgxTranslateFile(lang);\r\n    }\r\n\r\n    /**\r\n     * Warnings found during the run.\r\n     * @return warnings\r\n     */\r\n    public warnings(): string[] {\r\n        return this.parameters.warningsFound;\r\n    }\r\n\r\n    private readMaster() {\r\n        try {\r\n            this.master = TranslationMessagesFileReader.fromFile(\r\n                this.parameters.i18nFormat(),\r\n                this.parameters.i18nFile(),\r\n                this.parameters.encoding());\r\n            this.master.warnings().forEach((warning: string) => {\r\n                this.commandOutput.warn(warning);\r\n            });\r\n            const count = this.master.numberOfTransUnits();\r\n            const missingIdCount = this.master.numberOfTransUnitsWithMissingId();\r\n            this.commandOutput.info('master contains %s trans-units', count);\r\n            if (missingIdCount > 0) {\r\n                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);\r\n            }\r\n            const sourceLang: string = this.master.sourceLanguage();\r\n            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {\r\n                this.commandOutput.warn(\r\n                    'master says to have source-language=\"%s\", should be \"%s\" (your defaultLanguage)',\r\n                    sourceLang,\r\n                    this.parameters.defaultLanguage());\r\n                this.master.setSourceLanguage(this.parameters.defaultLanguage());\r\n                TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());\r\n                this.commandOutput.warn('changed master source-language=\"%s\" to \"%s\"', sourceLang, this.parameters.defaultLanguage());\r\n            }\r\n        } catch (err) {\r\n            if (err instanceof XliffMergeError) {\r\n                this.commandOutput.error(err.message);\r\n                return of(-1);\r\n            } else {\r\n                // unhandled\r\n                const currentFilename = this.parameters.i18nFile();\r\n                const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                this.commandOutput.error(filenameString + 'oops ' + err);\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the given language.\r\n     * Async operation.\r\n     * @param lang language\r\n     * @return on completion 0 for ok, other for error\r\n     */\r\n    private processLanguage(lang: string): Observable<number> {\r\n        this.commandOutput.debug('processing language %s', lang);\r\n        const languageXliffFile = this.parameters.generatedI18nFile(lang);\r\n        const currentFilename = languageXliffFile;\r\n        let result: Observable<void>;\r\n        if (!FileUtil.exists(languageXliffFile)) {\r\n            result = this.createUntranslatedXliff(lang, languageXliffFile);\r\n        } else {\r\n            result = this.mergeMasterTo(lang, languageXliffFile);\r\n        }\r\n        return result\r\n            .pipe(map(() => {\r\n                if (this.parameters.supportNgxTranslate()) {\r\n                    const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n                        TranslationMessagesFileReader.fromFile(\r\n                            this.translationFormat(this.parameters.i18nFormat()),\r\n                            languageXliffFile,\r\n                            this.parameters.encoding(),\r\n                            this.master.filename());\r\n                    NgxTranslateExtractor.extract(\r\n                        languageSpecificMessagesFile,\r\n                        this.parameters.ngxTranslateExtractionPattern(),\r\n                        this.parameters.generatedNgxTranslateFile(lang));\r\n                }\r\n                return 0;\r\n            }), catchError((err) => {\r\n                if (err instanceof XliffMergeError) {\r\n                    this.commandOutput.error(err.message);\r\n                    return of(-1);\r\n                } else {\r\n                    // unhandled\r\n                    const filenameString = (currentFilename) ? format('file \"%s\", ', currentFilename) : '';\r\n                    this.commandOutput.error(filenameString + 'oops ' + err);\r\n                    throw err;\r\n                }\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * create a new file for the language, which contains no translations, but all keys.\r\n     * in principle, this is just a copy of the master with target-language set.\r\n     * @param lang language\r\n     * @param languageXliffFilePath name of file\r\n     */\r\n    private createUntranslatedXliff(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // copy master ...\r\n        // and set target-language\r\n        // and copy source to target if necessary\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());\r\n        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(\r\n            map((/* summary */) => {\r\n            // write it to file\r\n            TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n            this.commandOutput.info('created new file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n            if (!isDefaultLang) {\r\n                this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Map the input format to the format of the translation.\r\n     * Normally they are the same but for xmb the translation format is xtb.\r\n     * @param i18nFormat format\r\n     */\r\n    private translationFormat(i18nFormat: string): string {\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return FORMAT_XTB;\r\n        } else {\r\n            return i18nFormat;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all\r\n     * @param lang language\r\n     * @param languageXliffFilePath filename\r\n     */\r\n    private mergeMasterTo(lang: string, languageXliffFilePath: string): Observable<void> {\r\n        // read lang specific file\r\n        const languageSpecificMessagesFile: ITranslationMessagesFile =\r\n            TranslationMessagesFileReader.fromFile(\r\n                this.translationFormat(this.parameters.i18nFormat()),\r\n                languageXliffFilePath,\r\n                this.parameters.encoding());\r\n        const isDefaultLang: boolean = (lang === this.parameters.defaultLanguage());\r\n        let newCount = 0;\r\n        let correctSourceContentCount = 0;\r\n        let correctSourceRefCount = 0;\r\n        let correctDescriptionOrMeaningCount = 0;\r\n        let idChangedCount = 0;\r\n        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());\r\n        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());\r\n        let lastProcessedUnit: ITransUnit = null;\r\n        this.master.forEachTransUnit((masterTransUnit) => {\r\n            const transUnit: ITransUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);\r\n\r\n            if (!transUnit) {\r\n                // oops, no translation, must be a new key, so add it\r\n                let newUnit;\r\n                if (this.parameters.allowIdChange()\r\n                    && (newUnit = this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {\r\n                    lastProcessedUnit = newUnit;\r\n                    idChangedCount++;\r\n                } else {\r\n                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n                        masterTransUnit,\r\n                        isDefaultLang,\r\n                        this.parameters.useSourceAsTarget(),\r\n                        (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n                    newCount++;\r\n                }\r\n            } else {\r\n                // check for changed source content and change it if needed\r\n                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.\r\n                if (transUnit.supportsSetSourceContent() && !this.areSourcesNearlyEqual(masterTransUnit, transUnit)) {\r\n                    transUnit.setSourceContent(masterTransUnit.sourceContent());\r\n                    if (isDefaultLang) {\r\n                        // #81 changed source must be copied to target for default lang\r\n                        transUnit.translate(masterTransUnit.sourceContent());\r\n                        transUnit.setTargetState(STATE_FINAL);\r\n                    } else {\r\n                        if (transUnit.targetState() === STATE_FINAL) {\r\n                            // source is changed, so translation has to be checked again\r\n                            transUnit.setTargetState(STATE_TRANSLATED);\r\n                        }\r\n                    }\r\n                    correctSourceContentCount++;\r\n                }\r\n                // check for missing or changed source ref and add it if needed\r\n                if (transUnit.supportsSetSourceReferences()\r\n                    && !this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {\r\n                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());\r\n                    correctSourceRefCount++;\r\n                }\r\n                // check for changed description or meaning\r\n                if (transUnit.supportsSetDescriptionAndMeaning()) {\r\n                    let changed = false;\r\n                    if (transUnit.description() !== masterTransUnit.description()) {\r\n                        transUnit.setDescription(masterTransUnit.description());\r\n                        changed = true;\r\n                    }\r\n                    if (transUnit.meaning() !== masterTransUnit.meaning()) {\r\n                        transUnit.setMeaning(masterTransUnit.meaning());\r\n                        changed = true;\r\n                    }\r\n                    if (changed) {\r\n                        correctDescriptionOrMeaningCount++;\r\n                    }\r\n                }\r\n                lastProcessedUnit = transUnit;\r\n            }\r\n        });\r\n        if (newCount > 0) {\r\n            this.commandOutput.warn('merged %s trans-units from master to \"%s\"', newCount, lang);\r\n        }\r\n        if (correctSourceContentCount > 0) {\r\n            this.commandOutput.warn('transferred %s changed source content from master to \"%s\"', correctSourceContentCount, lang);\r\n        }\r\n        if (correctSourceRefCount > 0) {\r\n            this.commandOutput.warn('transferred %s source references from master to \"%s\"', correctSourceRefCount, lang);\r\n        }\r\n        if (idChangedCount > 0) {\r\n            this.commandOutput.warn('found %s changed id\\'s in \"%s\"', idChangedCount, lang);\r\n        }\r\n        if (correctDescriptionOrMeaningCount > 0) {\r\n            this.commandOutput.warn(\r\n                'transferred %s changed descriptions/meanings from master to \"%s\"', correctDescriptionOrMeaningCount, lang);\r\n        }\r\n\r\n        // remove all elements that are no longer used\r\n        let removeCount = 0;\r\n        languageSpecificMessagesFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            const existsInMaster = !isNullOrUndefined(this.master.transUnitWithId(transUnit.id));\r\n            if (!existsInMaster) {\r\n                if (this.parameters.removeUnusedIds()) {\r\n                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);\r\n                }\r\n                removeCount++;\r\n            }\r\n        });\r\n        if (removeCount > 0) {\r\n            if (this.parameters.removeUnusedIds()) {\r\n                this.commandOutput.warn('removed %s unused trans-units in \"%s\"', removeCount, lang);\r\n            } else {\r\n                this.commandOutput.warn('keeping %s unused trans-units in \"%s\", because removeUnused is disabled', removeCount, lang);\r\n            }\r\n        }\r\n\r\n        if (newCount === 0 && removeCount === 0 && correctSourceContentCount === 0\r\n            && correctSourceRefCount === 0 && correctDescriptionOrMeaningCount === 0) {\r\n            this.commandOutput.info('file for \"%s\" was up to date', lang);\r\n            return of(null);\r\n        } else {\r\n            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)\r\n                .pipe(map(() => {\r\n                    // write it to file\r\n                    TranslationMessagesFileReader.save(languageSpecificMessagesFile, this.parameters.beautifyOutput());\r\n                    this.commandOutput.info('updated file \"%s\" for target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    if (newCount > 0 && !isDefaultLang) {\r\n                        this.commandOutput.warn('please translate file \"%s\" to target-language=\"%s\"', languageXliffFilePath, lang);\r\n                    }\r\n                    return null;\r\n                }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the case of changed id due to small white space changes.\r\n     * @param masterTransUnit unit in master file\r\n     * @param languageSpecificMessagesFile translation file\r\n     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.\r\n     * @return processed unit, if done, null if no changed unit found\r\n     */\r\n    private processChangedIdUnit(\r\n        masterTransUnit: ITransUnit,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile,\r\n        lastProcessedUnit: ITransUnit): ITransUnit {\r\n\r\n        let changedTransUnit: ITransUnit = null;\r\n        languageSpecificMessagesFile.forEachTransUnit((languageTransUnit) => {\r\n             if (this.areSourcesNearlyEqual(languageTransUnit, masterTransUnit)) {\r\n                 changedTransUnit = languageTransUnit;\r\n             }\r\n        });\r\n        if (!changedTransUnit) {\r\n            return null;\r\n        }\r\n        const mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(\r\n            masterTransUnit,\r\n            false,\r\n            false,\r\n            (this.parameters.preserveOrder()) ? lastProcessedUnit : undefined);\r\n        const translatedContent = changedTransUnit.targetContent();\r\n        if (translatedContent) { // issue #68 set translated only, if it is really translated\r\n            mergedTransUnit.translate(translatedContent);\r\n            mergedTransUnit.setTargetState(STATE_TRANSLATED);\r\n        }\r\n        return mergedTransUnit;\r\n    }\r\n\r\n    /**\r\n     * test wether the sources of 2 trans units are equal ignoring white spaces.\r\n     * @param tu1 tu1\r\n     * @param tu2 tu2\r\n     */\r\n    private areSourcesNearlyEqual(tu1: ITransUnit, tu2: ITransUnit): boolean {\r\n        if ((tu1 && !tu2) || (tu2 && !tu1)) {\r\n            return false;\r\n        }\r\n        const tu1Normalized = tu1.sourceContentNormalized();\r\n        const tu2Normalized = tu2.sourceContentNormalized();\r\n        if (tu1Normalized.isICUMessage()) {\r\n            if (tu2Normalized.isICUMessage()) {\r\n                const icu1Normalized = tu1Normalized.getICUMessage().asNativeString().trim();\r\n                const icu2Normalized = tu2Normalized.getICUMessage().asNativeString().trim();\r\n                return icu1Normalized === icu2Normalized;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        if (tu1Normalized.containsICUMessageRef()) {\r\n            const icuref1Normalized = tu1Normalized.asNativeString().trim();\r\n            const icuref2Normalized = tu2Normalized.asNativeString().trim();\r\n            return icuref1Normalized === icuref2Normalized;\r\n        }\r\n        const s1Normalized = tu1Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        const s2Normalized = tu2Normalized.asDisplayString(NORMALIZATION_FORMAT_DEFAULT).trim();\r\n        return s1Normalized === s2Normalized;\r\n    }\r\n\r\n    private areSourceReferencesEqual(\r\n        ref1: {sourcefile: string; linenumber: number; }[],\r\n        ref2: {sourcefile: string; linenumber: number; }[]): boolean {\r\n\r\n        if ((isNullOrUndefined(ref1) && !isNullOrUndefined(ref2)) || (isNullOrUndefined(ref2) && !isNullOrUndefined(ref1))) {\r\n            return false;\r\n        }\r\n        if (isNullOrUndefined(ref1) && isNullOrUndefined(ref2)) {\r\n            return true;\r\n        }\r\n        // bot refs are set now, convert to set to compare them\r\n        const set1: Set<string> = new Set<string>();\r\n        ref1.forEach((ref) => {set1.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        const set2: Set<string> = new Set<string>();\r\n        ref2.forEach((ref) => {set2.add(ref.sourcefile + ':' + ref.linenumber); });\r\n        if (set1.size !== set2.size) {\r\n            return false;\r\n        }\r\n        let match = true;\r\n        set2.forEach((ref) => {\r\n            if (!set1.has(ref)) {\r\n                match = false;\r\n            }\r\n        });\r\n        return match;\r\n    }\r\n\r\n    /**\r\n     * Auto translate file via Google Translate.\r\n     * Will translate all new units in file.\r\n     * @param from from\r\n     * @param to to\r\n     * @param languageSpecificMessagesFile languageSpecificMessagesFile\r\n     * @return a promise with the execution result as a summary report.\r\n     */\r\n    private autoTranslate(\r\n        from: string,\r\n        to: string,\r\n        languageSpecificMessagesFile: ITranslationMessagesFile): Observable<AutoTranslateSummaryReport> {\r\n\r\n        let serviceCall: Observable<AutoTranslateSummaryReport>;\r\n        const autotranslateEnabled: boolean = this.parameters.autotranslateLanguage(to);\r\n        if (autotranslateEnabled) {\r\n            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);\r\n        } else {\r\n            serviceCall = of(new AutoTranslateSummaryReport(from, to));\r\n        }\r\n        return serviceCall.pipe(map((summary) => {\r\n            if (autotranslateEnabled) {\r\n                if (summary.error() || summary.failed() > 0) {\r\n                    this.commandOutput.error(summary.content());\r\n                } else {\r\n                    this.commandOutput.warn(summary.content());\r\n                }\r\n            }\r\n            return summary;\r\n        }));\r\n    }\r\n\r\n}\r\n"]}